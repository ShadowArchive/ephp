%% @doc The PHP Array is a collection that could be used as a simple array
%%      or a hash. This module helps to create an structure to handle the
%%      PHP Array.
%%
%%      An example for the use of this module:
%%
%%      ```erlang
%%      Array0 = ephp_array:new().
%%      Array1 = ephp_array:store(auto, <<"hello world!">>).
%%      Array2 = ephp_array:store(auto, <<"bye!">>).
%%      ArrayN = ephp_array:from_list([1, 2, 3, 4, 5]).
%%      ```
%%
%%      It's possible to link the actions on the array to a specific module
%%      and function. This is useful to get the updates for an array in
%%      real-time.
%%
%%      The message received are the followings:
%%
%%      <ul>
%%      <li>`[Array, {retrieve, Key}]` get the information from
%%          the backend.</li>
%%      <li>`[Array, {add, Key, Value}]` add the key with the value for the
%%          array in the backend.</li>
%%      <li>`[Array, {update, Key, Value}]` change the value for the key in
%%          the array in the backend.</li>
%%      <li>`[Array, {remove, Key}]` removes the value for the key from the
%%          array in the backend.</li>
%%      <li>`[Array, {map, Fun}]` run the map function for the array in the
%%          backend.</li>
%%      <li>`[Array, {fold, Fun, Initial}]` run the fold function for the
%%          array in the backend.</li>
%%      <li>`[Array, to_list]` transfor the array in a property list from
%%          the array.</li>
%%      </ul>
%% @end
-module(ephp_array).
-author('manuel@altenwald.com').
-compile([warnings_as_errors]).

-include("ephp.hrl").

-export([
    new/0,
    new/3,
    size/1,
    find/2,
    find/3,
    store/3,
    erase/2,
    map/2,
    fold/3,
    from_list/1,
    to_list/1
]).


-spec new() -> ephp_array().
%% @doc creates an empty PHP Array structure.
new() -> #ephp_array{}.


-spec new(module(), function(), [any()]) -> ephp_array().
%% @doc creates an empty PHP Array structure linked to a module and
%%      function. To handle the internal information.
%% @end
new(Module, Function, Args) ->
    #ephp_array{trigger = {Module, Function, Args}}.


-spec size(ephp_array()) -> non_neg_integer().
%% @doc retrieve the size of the array.
size(#ephp_array{size=Size}) -> Size.


-spec find(mixed(), ephp_array()) -> {ok, mixed()} | error.
%% @doc finds an element by the key passed as a param.
find(Key, #ephp_array{values=Values, trigger=undefined}) ->
    case lists:keyfind(Key, 1, Values) of
        {Key, Value} -> {ok, Value};
        false -> error
    end;

find(Key, #ephp_array{trigger={Module,Function,Args}}=Array) ->
    apply(Module, Function, Args ++ [Array, {retrieve, Key}]).


-spec find(mixed(), ephp_array(), mixed()) -> mixed().
%% @doc finds an element by the passed as a param. If the value isn't found the
%%      default value passed as param is returned.
%% @end
find(Key, Array, Default) ->
    case find(Key, Array) of
        {ok, Value} -> Value;
        error -> Default
    end.


-spec store(auto | mixed(), mixed(), ephp_array()) -> ephp_array().
%% @doc stores a new element given a key and a value. If the key passed is
%%       `auto` the key is autogenerated based on the last numeric index
%%       used.
%% @end
store(auto, Value,
      #ephp_array{last_num_index = Key, values = Values} = Array) ->
    report(Array#ephp_array{
        last_num_index = Key + 1,
        values = Values ++ [{Key, Value}],
        size = Array#ephp_array.size + 1
    }, {add, Key, Value});

store(Key, Value, #ephp_array{last_num_index = Last, values = Values} = Array)
        when is_integer(Key) andalso Key >= 0
        andalso Last =< Key ->
    report(Array#ephp_array{
        last_num_index = Key + 1,
        values = Values ++ [{Key, Value}],
        size = Array#ephp_array.size + 1
    }, {add, Key, Value});

store(Key, Value, #ephp_array{values = Values} = Array) ->
    case lists:keyfind(Key, 1, Values) =/= false of
        true ->
            NewValues = lists:keyreplace(Key, 1, Values, {Key, Value}),
            Action = update,
            Size = Array#ephp_array.size;
        false ->
            NewValues = Values ++ [{Key, Value}],
            Action = add,
            Size = Array#ephp_array.size + 1
    end,
    report(Array#ephp_array{
        values = NewValues,
        size = Size
    }, {Action, Key, Value}).


-spec erase(mixed(), ephp_array()) -> ephp_array().
%% @doc removes an element from the array given the index.
erase(Key, #ephp_array{values=Values}=Array) ->
    NewValues = lists:keydelete(Key, 1, Values),
    report(Array#ephp_array{
        values = NewValues,
        size = length(NewValues)
    }, {remove, Key}).


-spec map(function(), ephp_array()) -> ephp_array().
%% @doc performs a map action on all of the elemnts in the array.
map(Fun, #ephp_array{values = Values, trigger = undefined} = Array) ->
    NewValues = lists:map(fun({K, V}) -> Fun(K, V) end, Values),
    Array#ephp_array{values = NewValues};

map(Fun, #ephp_array{trigger = {Module, Function, Args}} = Array) ->
    NewFun = fun({K, V}) -> Fun(K, V) end,
    apply(Module, Function, Args ++ [Array, {map, NewFun}]).


-spec fold(function(), mixed(), ephp_array()) -> mixed().
%% @doc performs a fold on all of the elements in the array given an initial
%%      value and changing that value in each element.
%% @end
fold(Fun, Initial, #ephp_array{values = Values, trigger = undefined}) ->
    lists:foldl(fun({K, V}, Acc) -> Fun(K, V, Acc) end, Initial, Values);

fold(Fun, Initial, #ephp_array{trigger = {Module, Function, Args}} = Array) ->
    NewFun = fun({K, V}, Acc) -> Fun(K, V, Acc) end,
    apply(Module, Function, Args ++ [Array, {fold, NewFun, Initial}]).


-spec from_list([mixed()]) -> ephp_array().
%% @doc transform the list passed as param in a PHP Array.
from_list(List) when is_list(List) ->
    lists:foldl(fun
        ({K,_}=E, #ephp_array{values = V, size = S} = A) when is_binary(K)
                                                       orelse is_number(K) ->
            A#ephp_array{size = S + 1, values = V ++ [E]};
        (E, #ephp_array{values = V, last_num_index = K, size = S} = A) ->
            A#ephp_array{size = S + 1, values = V ++ [{K,E}],
                         last_num_index = K + 1}
    end, #ephp_array{}, List).


-spec to_list(ephp_array()) -> [mixed()].
%% @doc transform a PHP Array to a property list.
to_list(#ephp_array{values = Values, trigger = undefined}) ->
    Values;

to_list(#ephp_array{trigger = {Module, Function, Args}} = Array) ->
    apply(Module, Function, Args ++ [Array, to_list]).

%% -----------------------------------------------------------------------------
%% Internal functions
%% -----------------------------------------------------------------------------

-type action() :: {add | update, Key :: mixed(), Value :: mixed()} |
                  {remote, Key :: mixed()}.

-spec report(ephp_array(), action()) -> ephp_array().
%% @hidden
report(#ephp_array{trigger = undefined} = Array, _) ->
    Array;

report(#ephp_array{trigger = {Module, Function, Args}} = Array, Action) ->
    apply(Module, Function, Args ++ [Array, Action]).
